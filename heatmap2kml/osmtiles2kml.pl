#!/usr/bin/perl -wT

# This CGI script is an adapter for getting OSM slippy map tiles into Google
# Earth.

# I use the onStop view refresh mode to serve a KML file containing all the OSM
# OSM tiles you need for the current view from Google Earth. This approach
# differs from the top down pyramid approach used by TileCache.

# Author: Andrew Harvey <andrew.harvey4@gmail.com>
# License: CC0 http://creativecommons.org/publicdomain/zero/1.0/
#
# To the extent possible under law, the person who associated CC0
# with this work has waived all copyright and related or neighboring
# rights to this work.
# http://creativecommons.org/publicdomain/zero/1.0/

use strict;

# load CGI routines for getting parameters
use CGI qw/:standard/;
use CGI::Pretty;

# OSM tiles to lat,lon
# Code snippet from http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Perl
use Math::Trig;
sub Project {
  my ($X,$Y, $Zoom) = @_;
  my $Unit = 1 / (2 ** $Zoom);
  my $relY1 = $Y * $Unit;
  my $relY2 = $relY1 + $Unit;

  # note: $LimitY = ProjectF(degrees(atan(sinh(pi)))) = log(sinh(pi)+cosh(pi)) = pi
  # note: degrees(atan(sinh(pi))) = 85.051128..
  #my $LimitY = ProjectF(85.0511);

  # so stay simple and more accurate
  my $LimitY = pi;
  my $RangeY = 2 * $LimitY;
  $relY1 = $LimitY - $RangeY * $relY1;
  $relY2 = $LimitY - $RangeY * $relY2;
  my $Lat1 = ProjectMercToLat($relY1);
  my $Lat2 = ProjectMercToLat($relY2);
  $Unit = 360 / (2 ** $Zoom);
  my $Long1 = -180 + $X * $Unit;
  return ($Lat2, $Long1, $Lat1, $Long1 + $Unit); # S,W,N,E
}
sub ProjectMercToLat($){
  my $MercY = shift;
  return rad2deg(atan(sinh($MercY)));
}
sub ProjectF
{
  my $Lat = shift;
  $Lat = deg2rad($Lat);
  my $Y = log(tan($Lat) + sec($Lat));
  return $Y;
}

# lat,lon to OSM tile
# Code snippet from http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Perl
sub getTileNumber {
  my ($lat,$lon,$zoom) = @_;
  my $xtile = int( ($lon+180)/360 *2**$zoom ) ;
  my $ytile = int( (1 - log(tan(deg2rad($lat)) + sec(deg2rad($lat)))/pi)/2 *2**$zoom ) ;
  return ($xtile, $ytile);
}

# lat limit of the OSM tiles
my $LAT_LIMIT = 85.0511;

# declare functions
sub renderTile($$$);
sub tiles($$$$$);

# the max zoom level for which the tile url will accept. use undef for no limit
my $ZOOM_CAP = 21;

# because of the projection OSM tiles have, we can't just let Google Earth wrap
# one z0 tile around the earth and expect it to be in the right place everywhere
# so we overzoom at low zooms to minimise the effects of this
# The downside, is a lot of tiles may be requested, i.e. for a low limit of z4,
# you could have (2^4 * 2^4) / 2 tiles being requested for one view.
my $LOW_ZOOM_LIMIT = 2;

my $TILE_URL = "https://heatmap-external-a.strava.com/tiles/ride/blue/";
my $KML_URL = "http://localhost/"; # location of this script

my $bbox = param('bbox');
my $px = param('px');
my $py = param('py');

print "Content-Type: application/vnd.google-earth.kml+xml\n";
print "\n";

print '<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://earth.google.com/kml/2.1">
<!-- Generated by a CC0 licensed program. See https://gist.github.com/1638955 -->
';

# if this is the first request by Google Earth to this KML file
# tell Google Earth to ask for this file again with the view bounds
if (!defined $bbox) {
    print "  <Document>
    <NetworkLink>
      <name>view</name>
      <Link>
        <href>$KML_URL</href>
        <viewRefreshMode>onStop</viewRefreshMode>
        <viewRefreshTime>0</viewRefreshTime>
        <viewFormat>bbox=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]&amp;px=[horizPixels]&amp;py=[vertPixels]</viewFormat>
      </Link>
    </NetworkLink>
  </Document>\n";
}else{
    $bbox =~ s/[^0-9\.\,\-]//g; # remove any unexpected characters

    $px =~ s/[^0-9]//g; # remove any non digit character
    $py =~ s/[^0-9]//g; # remove any non digit character

    # parse bbox string
    my ($l, $b, $r, $t) = split /,/, $bbox;
    if ((defined $l && defined $b && defined $r && defined $t && defined $px && defined $py) &&
        (($r > $l) && ($t > $b)) && 
        ($px > 0 && $py > 0)) {
        my $degPerXPixel = ($r - $l) / $px;


        # FIXME do some proper reasoning behind finding the zoom value

        # may or may not be true due to projection, but roughly
        # zoom 0 = 360 degrees per tile
        # z1 = 180
        # z2 = 90
        # z3 = 45
        # zn = 360 / (2^n)

        # so zoom = log_2 (360/(r-l))
        my $zoom = int(log(360 / ($r - $l)) / log (2));
        $zoom += 3;

        # cap the zoom so if the user zooms in a lot, we just pixelate the tiles
        # rather than requesting tiles which would 404
        if ((defined $ZOOM_CAP) && ($zoom > $ZOOM_CAP)) {
            $zoom = $ZOOM_CAP;
        }

        if ($zoom < $LOW_ZOOM_LIMIT) {
            $zoom = $LOW_ZOOM_LIMIT;
        }

        print "  <Document>\n";
        # tiles don't cover the polar regions so cap them out
        if ($t > $LAT_LIMIT) {
            $t = $LAT_LIMIT;
        }elsif ($t < -$LAT_LIMIT) {
            $t = -$LAT_LIMIT;
        }

        if ($b > $LAT_LIMIT) {
            $b = $LAT_LIMIT;
        }elsif ($b < -$LAT_LIMIT) {
            $b = -$LAT_LIMIT;
        }

        print "    <!-- tiles for the region $l, $b, $r, $t at z$zoom -->\n";
        my $tileCount = tiles($l, $b, $r, $t, $zoom);
        print "  </Document>\n";
    }
}
print "</kml>\n";

# generate all the tiles for this area
sub tiles($$$$$) {
    my ($l, $b, $r, $t, $zoom) = @_;

    my ($left, $top) = getTileNumber($t, $l, $zoom);
    my ($right, $bottom) = getTileNumber($b, $r, $zoom);

    my $tileCount = 0;

    for my $x ($left..$right) {
        for my $y ($top..$bottom) {
            renderTile($x, $y, $zoom);
            $tileCount++;
        }
    }

    return $tileCount;
}

sub renderTile($$$) {
    my ($x, $y, $z) = @_;

    my ($b, $l, $t, $r) = Project($x, $y, $z);

    print "    <GroundOverlay>
      <drawOrder>0</drawOrder>
      <Icon>
        <href>${TILE_URL}/$z/$x/$y.png?v=19</href>
      </Icon>
      <LatLonBox>
        <north>$t</north><south>$b</south>
        <east>$r</east><west>$l</west>
      </LatLonBox>
    </GroundOverlay>\n";
}